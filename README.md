### Professional Self-Assessment
	The journey of pursuing a degree in computer science is long, rewarding, and challenging. For developing an ePortfolio, it was imperative that the projects have variation and flexibility to demonstrate the ability to adapt and accommodate. In the computer science program, the material presented a great deal of variability that is sure to prepare the student for a number of careers. While I do not have intentions to become a software developer, I am happier knowing that I have used many of the tools and techniques that companies seek in applicants. Other material presented throughout the course complemented preexisting skills in the realm of IT. Furthering my skills in Active Directory, understanding the principal of least privilege, becoming familiar with virtual environments, and getting hands on experience with collaborative atmospheres have been invaluable for developing a solid foundation in the field.
	As my first formal introduction to coding in a collaborative environment, Git was integrated with Visual Studio to facilitate code integration among peers. Other projects used a start-to-finish approach where an itinerary was developed, pseudocode was presented, rough iterations of the project were created, then polished projects were pushed for final reviews; this was effective for learning how to communicate with stakeholders throughout the software development lifecycle. For this course, taking on a variety of projects helped to hone programming and problem-solving skills that some companies may use in the event of a coding interview.
	The Guessing Game software engineering and design project was a fairly simple program intended to demonstrate solid foundations in syntax, commenting, logic, functionality, and error-handling. The Binary Tree data structures and algorithms was significantly more involved and more complex. Its purpose was to display more advanced concepts and abstraction in order to provide functions that are likely to be witnessed in the workplace. The SQLite C++ Databases project was a more unique undertaking. It integrated preexisting 3rd party libraries to facilitate communication between an IDE and SQL software in order to locally manage databases and stored data. While each program was written in C++, their diversity in structure and intended function are highly diverse.
### Software Design and Engineering
	The Guessing Game foundation was created in Module 1, further enhancements were added in Module 3. While creating an interactive guessing game program is not particularly innovative, it is an effective program to showcase fundamentals in C++ and demonstrate clean design. Beyond the obvious basics of a guessing game, this program incorporates additional interactivity with the user by allowing them to determine the maximum range in which the mystery number can exist, then generating a random mystery number, and calculating the number of guesses the user is allowed based on the size of the range. 
	Initially, the guessing game only used hard-coded variables, the user had an infinite number of guesses, and user input was not checked to ensure that integers were entered. Enhancements were made to allow the user additional control over the parameters of the program, limit the number of guesses, and increase replay-ability of the program by randomly generating the mystery number. In order to accommodate additional enhancements in the program, some changes were required: additional variables, conditions to check user input before attempting to store it within an integer variable (i.e. check to make sure the user did not enter a char), additional prompts for the user to enter parameters, and a counting variable to be decremented with each iteration of the gameplay loop to determine when the user has run out of guesses.
	All planned enhancements were successfully implemented in the software design and engineering program. The majority of the logic initially implemented in the program laid the foundation for the current iteration of the program. There were a number of challenges faced while integrating the new enhancements with the original code: some restructuring was necessary for adding checks to user input, adding a way to randomly generate a mystery number, and adding additional ways for the user to interact with the program. While none of the additions are meant to explicitly intended to enhance security, fixing the while loop by prompting the user to enter an integer if they enter a char, then rejecting the char.
	Though the nature of the program does not necessarily call for a security mindset that anticipates exploitation of potential vulnerabilities, the program was designed to avoid misuse. While other games, such as ones that require login credentials or have competitive leaderboards, demand security, this program does not, yet following best practices was still kept in mind. Initial implementation of this program would have been subject to exploitation had the while loop not been restructured to reject invalid user input. There were also a number of hard-coded variables in the beginning, which given this program’s functionality, is not entirely concerning; however, if this program had been adapted to use login credentials or keep track of score, then the hard-coded variables could have been taken advantage of. The user chooses variables in place of the once hard-coded variables and all input is validated through logic. Logic errors, compiler warnings, and improper variable types were all eliminated through the development of this project.
### Algorithms and Data Structure
	The foundation for the Binary Tree program was initially created Module 1 and further enhancements were recently added in Module 4. While the purpose of this exercise is mainly to serve as a challenge for developing popular algorithms that manipulate data in the form of a Binary Tree, there are additional benefits to this choice. In some example interviews for developers, Binary Trees and similar structures are often mentioned; additional practice and familiarity with these data structures may not be a daily focus for most developers, but understanding the fundamentals and how these algorithms work demonstrates proficiency in several areas including working with abstract concepts, efficiently manipulate and search through data, and create modular code that supports scaling and other enhancements.
	Meeting planned course objectives and code enhancements are still a work in progress. The pseudocode created in Module 1 for the Binary Tree served as an effective foundation for the structure and rough logic for the program. Both the create/insert node and search functions are fully functional and have been integrated into a user menu; however, the delete function has been causing more issues than anticipated and will require additional tweaking. The delete ability has also been added to the user menu and consists of two functions. One function’s purpose is to identify the node at the deepest, rightmost position; the other function is meant to find the node to be deleted, change its value to null, then insert the deepest, rightmost node into the temporary node. I believe the logic and functionality are very close to where they need to be, but it remains a work in progress.
	Thankfully, the modularity of the program has allowed for excessive amounts of tweaking, error handling, and logical flow. Prior to the most recent enhancements, there was an issue in how the Main function was being organized. Due to the potentially conflicting behavior between creating/inserting, searching, and deleting nodes, each function was called in Main, but needed to be commented out to avoid conflict. Now that a user menu exists, code within Main does not need to be altered to run each function and explore the full functionality of the Binary Tree.
	The nature of the Binary Tree is to run locally and only function in working memory. This means that there is no concern for sanitization of credentials, the need to limit the scope of network availability, or fear of misuse. Although the potential harm for a program such as this is limited to the local host, it was still essential to handle pointers and memory allocation properly. All temporary pointers that were created were later initialized as null to properly manage memory and avoid undefined behavior. Checks for logic errors, compiler warnings, and improper use of variables were once again all considerations during the development of this program, although there was still one remaining error in regard to running the delete function.
### Databases
	The foundation for the SQLite3 integration with C++ was initially created in Module 1 and further enhancements began in Module 5 and stretched into the following week. While the practicality of this program in real world environments is questionable, it served as an effective learning exercise for creating and manipulating data stored within a database through an IDE using C++. With this integration, the program is able to create databases, create tables, insert records, update records, delete records, and query using SQL language. The inclusion of this artifact was mainly for the novelty of incorporating different environments, languages, and functions into one creation. Modularity was one of the main focuses for this program; additional enhancements were added with minimal restructuring required; new code blocks were seamlessly assimilated with the existing code.
	Meeting all planned course objectives was more time consuming than anticipated; however, the program works as intended, has error handling for each function, and is controlled by the user via the switch menu. While implementing the switch menu to create a user menu was a trivial task, it transformed the program. Previously, functions in Main had to be commented out to avoid causing conflicts between operations, i.e. delete and insert. The program is technically written in C++ but is rooted in C along with the library that allows SQL commands to be used. Most of the challenges faced while creating this program were time consuming, not necessarily complicated such as being introduced to SQLite3, refreshing SQL knowledge, and reading documentation for SQLite3 and the library to make it work with C++.
	Typically, databases are hosted on platforms other than local machines; however, in this instance, all data and commands were run locally. Had this program intended to use network resources, login would be required, and credentials would need to be sanitized to ensure security of the sensitive information. Additionally, depending on the nature of the data within the SQL database, encryption may have been necessary to protect the information in the event of a breach. Each available SQL command possessed error-handling and the allowed user inputs were each acknowledged through a switch statement; valid input would carry out the SQL commands, while invalid input would exit the program to combat misuse.
### Code Reviews
[Software Engineering/Design](https://www.youtube.com/watch?v=OkAafFWjnWw)
[Algorithms & Data Structure](https://www.youtube.com/watch?v=QLe8jZrO_lA)
[Databases](https://www.youtube.com/watch?v=pwh7RPcIp9I)
